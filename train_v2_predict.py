# -*- coding: utf-8 -*-
"""for predict"""
"""idontknow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11jA_Z_PItmB-P3BkIvgxXVpwi9_iPufb

# 建立資料
建立964*49的list(964筆資料、每筆有49個data)
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np
import time
start = time.time()
name = 'mix90-97'
data=[]
with open(name+'.txt',encoding='utf8') as f:
    for line in f:
      data.append(line.split())

# print(data)
# print(len(data))
score=[]
game=[]

# print(np.shape(data))
for i in range(len(data)):
  if i%9==0:
    # score.append(float(data[i][0])/540.0)
    score.append(float(data[i][0]))
  elif i%9!=8:
    for j in range(7):
      # data[i][j] = float(data[i][j])/10.0
      data[i][j] = float(data[i][j])
    game.append(data[i])

# print(score)
# print(game)
# print(len(game))
'''
tmp = []
game_1d = []
for i in range(len(game)):
  if i%7==0 and i!=0:
    game_1d.append(tmp)
    tmp = []
  # tmp.append(-1)
  for j in range(7):
    tmp.append(game[i][j])
  # tmp.append(-1)

  
game_1d.append(tmp)
print(game_1d[0])
# print(len(game_1d))
# print(len(game_1d[0]))
'''

game_2d=[]
num = []
for i in range(len(game)):
  if i%7==0 and i!=0:
    game_2d.append(num)
    num = []
  num.append(game[i])

game_2d.append(num)
num = []
# print(game_2d)
# print(len(score))
# print(len(game_2d))

game_1d=[]
tmp = []
for i in range(len(game_2d)):
  for j in range(7):
    tmp.append(game_2d[i][j])
  game_1d.append(tmp)

# print(game_1d[0])
# print(len(game_1d))


# 計算剩餘顏色
color = [0, 0, 0, 0, 0, 0, 0]
color_list = []
for i in range(len(game_2d)):
  for j in range(7):
      for k in range(7):
        if game_2d[i][j][k]==1:
          color[0]+=1
        elif game_2d[i][j][k]==2:
          color[1]+=1
        elif game_2d[i][j][k]==3:
          color[2]+=1
        elif game_2d[i][j][k]==4:
          color[3]+=1
        elif game_2d[i][j][k]==5:
          color[4]+=1
        elif game_2d[i][j][k]==6:
          color[5]+=1
        elif game_2d[i][j][k]==7:
          color[6]+=1
  for i in range(7):
    color[i] = 7-color[i]
  color_list.append(color)
  color = [0, 0, 0, 0, 0, 0, 0]
  
# 2D盤面(數字表示他的row和col有同樣顏色的個數)
game_same_color_num = []
tmp_list = []
tmp = []
tmp2 = []
# print(game_2d[0])
for i in range(len(game_2d)):
    for j in range(7):
      for k in range(7):
        num = -1
        space = 0
        for m in range(7):
          if game_2d[i][j][m] == game_2d[i][j][k]:
            num+=1
          if game_2d[i][j][m] == 0:
            space+=1
          if game_2d[i][m][k] == game_2d[i][j][k]:
            num+=1
          if game_2d[i][m][k] == 0:
            space+=1
        # 目前盤面同色個數
        tmp.append(num)
        # 不是空格
        if game_2d[i][j][k]!=0:
            # 幾個空格
            tmp.append(space)
            tmp.append(color_list[i][int(game_2d[i][j][k])-1])
        else:
            #是空格
            tmp.append(num)
            tmp.append(0)
            
    game_same_color_num.append(tmp)
    tmp = []
# print('game_same_color_num', game_same_color_num)
# print(game_same_color_num[0])
# print(len(game_same_color_num[0]))

"""# 生成輸入"""
# print(tf.__version__)
# (x_train, y_train), (x_test, y_test) = mnist.load_data()
# x_train, x_test = x_train / 255.0, x_test / 255.0
x_train = []
y_train = []
x_test = []
y_test = []
'''
# 一維
for i in range(len(game_1d)):
  if i < (len(game_1d)*0.8):
    x_train.append(game_1d[i])
    y_train.append(score[i])
  else:
    x_test.append(game_1d[i])
    y_test.append(score[i])
print(x_test[0])
'''

# game_same_color_num 一維
# 打亂訓練樣本

game_same_color_num = np.array(game_same_color_num)
score = np.array(score)
order = np.random.randint(0, len(game_same_color_num), size = len(game_same_color_num))
game_same_color_num = game_same_color_num[order]
score = score[order]

for i in range(len(game_same_color_num)):
  if i < (len(game_same_color_num)*0.8):
    x_train.append(game_same_color_num[i])
    y_train.append(score[i])
  else:
    x_test.append(game_same_color_num[i])
    y_test.append(score[i])

#改成numpy array
x_train = np.array(x_train)
y_train = np.array(y_train)
x_test = np.array(x_test)
y_test = np.array(y_test)
# 資料正規化
'''
mean = x_train.mean(axis=0)
std = x_train.std(axis = 0) # 標準差
x_train = (x_train-mean)/std
x_test = (x_test-mean)/std
'''
print(type(x_train))
print(type(y_train))
print(type(x_test))
print(type(y_test))

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)
# print(y_train[0:5])
# print(y_test[0:5])
# print(x_train[0])

"""# 神經網路"""

import tensorflow as tf
# 建神經網路
model = tf.keras.Sequential(
        [tf.keras.layers.Dense(147, activation='relu',input_shape=(147, )),  #參數:數量,活化函數,每筆data數
         tf.keras.layers.Dense(147, activation='relu'),
         tf.keras.layers.Dense(147, activation='relu'),
        
        # tf.keras.layers.Dense(147, activation='relu'),
        # tf.keras.layers.Dense(147, activation='relu'), 
        # tf.keras.layers.Dense(147, activation='relu'),
        #  tf.keras.layers.Dense(147, activation='relu'),
        #  tf.keras.layers.Dense(147, activation='relu'),
        #  tf.keras.layers.Dense(147, activation='relu'),
        tf.keras.layers.Dense(1)]) #最後輸出結果只有1個

model.compile(optimizer='adam',
        loss='mse',
        metrics=['mae'])
# 設定early stopping
early_stop = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=20)
history = model.fit(x_train, y_train, batch_size=16,  epochs=500, validation_split=0.2, callbacks=[early_stop])
# history = model.fit(x_train, y_train, batch_size=16,  epochs=400, validation_split=0.2)


end = time.time()


# 評估
test_loss, test_mae = model.evaluate(x_test, y_test)
print('loss:{:.3f}\nmae: {:.3f}'.format(test_loss, test_mae))

"""# 測試結果"""

#測試結果
print(x_test[0])
print('前十筆測試標籤', y_test[0:10])
test_predictions = model.predict(x_test[0:10], verbose = 0).flatten()
print('前十筆預測結果', np.round(test_predictions))

print('相差(預測-測試) [', end="")

for i in range(10):
  test = model.predict(x_test[i:i+1], verbose = 0)
  ans = (test[0][0]-y_test[i])
  print(np.round(ans), end=" ")
print(']')
print('Total run time = ', str(round(end - start, 5)), ' seconds.\n')

"""# 作圖"""

import matplotlib.pyplot as plt

plt.plot(history.history['mae'], label = 'train loss')
plt.plot(history.history['val_mae'], label = 'val loss')

plt.xlabel('epoch')
# plt.ylabel('mae')
plt.ylabel('loss')
plt.legend(loc='best')
# plt.ylim([0, 5])
plt.show()

# 儲存訓練模型為HD5檔
model.save(name+'.h5')
'''
# 準備 x_test 與 y_test 資料 ... [略]

# 從 HDF5 檔案中載入模型
model = tf.contrib.keras.models.load_model('my_model.h5')

# 評估模型
score = model.evaluate(x_test, y_test, verbose=0)

# 輸出結果
print('Test loss:', score[0])
print('Test accuracy:', score[1])

#測試
test_predictions = model.predict(x_test, verbose = 0).flatten()
'''